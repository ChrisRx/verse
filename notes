TODO
----

need to change the way global func decls are handled
    - should be one pass first to find each of them, then another to do the rest of the parsing
parsing needs to be done better, parser should be aware of current declaration (declared return type)
    - keep a "current scope"?
    - already returned
func calls need to be properly parsed, right now they are coerced to an int if not found.
In order to fix this, an "extern" global func declaration will first be needed


function declarations should create unique labels to be called from, and if they use local variables, the "instance" of the function includes their values at the time of creation

fn thing(x:int): fn<int->int> {
    return fn (y:int) {
        return {x} + y;
    };
}

.thing:

y:string = "1";
y:string = x; // x is copied into a new allocation for y
y = x; // reuse same allocation, copy x
x:string = "test" + y;  // "test" + y creates as temp var, which will be deleted at end of scope if not consumed
// in declaration for a dynamic type (string, dyn array,...) if RHS is a temp var, skip allocation and assign directly (consuming temp var)
// make space for temp var addresses during stack allocation?
printf("x: " + x); // creates a temp var which is not copied into the function call args
y = fmt("x: %s", x); // function call returns a temp var that is not copied when it is assigned
fmt("big string: %s", y); // 
